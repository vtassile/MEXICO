{
    "collab_server" : "",
    "contents" : "library(shiny)\nlibrary(shinydashboard)\nlibrary(FactoMineR)\nlibrary(lme4)\nlibrary(matrixcalc)\nlibrary(cluster)\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(networkD3)\nlibrary(DT)\nlibrary(d3Network)\nlibrary(RCurl)\nlibrary(leaflet)\nlibrary(highcharter)\nlibrary(dendextend)\nlibrary(circlize)\nlibrary(ggfortify)\nlibrary(d3heatmap)\nlibrary(ggplot2)\nlibrary(ggdendro)\nlibrary(plotly)\nlibrary(googleVis)\n#library(htmltools)\n#library(exportwidget)\n#library(webshot)\n#library(highcharter)\nlibrary(data.table)\nlibrary(lubridate)\nlibrary(mxmaps)\nlibrary(scales) # needed for comma\nlibrary(viridis)\n\nshinyServer(function(input, output,session) {\n\n  output$localPlot <- renderPlotly({\n    FIN_2<-dim(COMBO_MES)[1]\n    COMBO_MES$MES2<-1:FIN_2\n    NUEVO_2<-left_join(MAESTRO_1,COMBO_MES[,c(3:5)],fill = 0)\n    NUEVO_2$EMPRESA<-as.factor(NUEVO_2$EMPRESA)\n    # GENERA CODIGOS PARA PRODUCTOR LOS INCORPORA A LA BASE NUEVO_1\n    EMPRESAS<-as.data.frame(unique(NUEVO_2$EMPRESA))\n    names(EMPRESAS)<-\"EMPRESA\"\n    LIMITE<-dim(EMPRESAS)[1]\n    EMPRESAS$N_ENTIDAD<-1:LIMITE\n    NUEVO_2<-left_join(NUEVO_2,EMPRESAS)\n    #### DEFINE LAS VARIABLES\n    TEMPO<-NUEVO_2\n    RESPUESTA<-\"MES\"\n    TEMPO$RESPUESTA<-RESPUESTA\n    TEMPO$UNIDAD<-TEMPO$TEMPORADA\n    ### CONSTRUYE LA VARIABLE PARA CRUZAR\n    TEMPO<-unite_(TEMPO, \"ESTRATO2\", c(\"RESPUESTA\",\"MES\"))\n    #### GENERA LOS GRUPOS PARA EL CRUCE\n    #### CAMBIAR LA VARIABLE DENTRO DE mean PARA QUE COINCIDA CON RESPUESTA\n    TEMPO2<-TEMPO %>% group_by(UNIDAD,ZONA_DESTINO,ESTRATO2) %>% summarise(mean(KILOS))\n    names(TEMPO2)[4]<-\"TOTAL\"\n    ###### REALIZA EL CRUCE\n    TEMPO3<-TEMPO2 %>% spread(ESTRATO2,TOTAL,fill = 0)\n    TEMPO3<-as.data.frame(TEMPO3)\n    TEMPO3_1<-TEMPO3\n    TEMPO3_1<-unite_(TEMPO3_1, \"ESTRATO3\", c(\"UNIDAD\",\"ZONA_DESTINO\"))\n    rownames(TEMPO3_1) <-as.character(TEMPO3_1[1][,1])\n    TEMPO3_2<-TEMPO3_1[,2:dim(TEMPO3_1)[2]]\n    ##### identifica los clusters\n    hc <- hclust(dist(TEMPO3_2), \"ave\")\n    GRUPO=cutree(hc,k=5) \n    GRUPO<-as.data.frame(GRUPO)\n    GRUPO$ESTRATO3<-rownames(GRUPO)\n    GRUPO$ESTRATO3<-as.factor(GRUPO$ESTRATO3)\n    TEMPO3_1$ESTRATO3<-as.factor(TEMPO3_1$ESTRATO3)\n    TEMPO5<-left_join(GRUPO, TEMPO3_1)\n    rownames(TEMPO5) <-as.character(TEMPO5[2][,1])\n    TEMPO5<-TEMPO5[,c(1,3:dim(TEMPO5)[2])]\n    V_CP1<-summary(prcomp(TEMPO5[,2:dim(TEMPO5)[2]], scale = TRUE))$importance[2]*100\n    V_CP2<-summary(prcomp(TEMPO5[,2:dim(TEMPO5)[2]], scale = TRUE))$importance[5]*100\n    Var_CP1<-paste(\"Primer Componente (\",V_CP1,\"%)\",sep=\"\")\n    Var_CP2<-paste(\"Segunda Componente (\",V_CP2,\"%)\",sep=\"\")\n    p<-autoplot(prcomp(TEMPO5[,2:dim(TEMPO5)[2]],scale=TRUE),\n                label = TRUE, colour = TEMPO5$GRUPO, label.size = 3,\n                loadings = TRUE, loadings.colour = 'blue',loadings.label = TRUE, \n                loadings.label.size = 4,shape = TRUE, frame = FALSE,\n                xlab =Var_CP1,ylab=Var_CP2,main=\"AnÃ¡lisis de Componentes Principales\")\n    (gg <- ggplotly(p))\n  })\n\n  output$heatmap <- renderD3heatmap({\n    FIN_2<-dim(COMBO_MES)[1]\n    COMBO_MES$MES2<-1:FIN_2\n    NUEVO_2<-left_join(MAESTRO_1,COMBO_MES[,c(3:5)],fill = 0)\n    NUEVO_2$EMPRESA<-as.factor(NUEVO_2$EMPRESA)\n    # GENERA CODIGOS PARA PRODUCTOR LOS INCORPORA A LA BASE NUEVO_1\n    EMPRESAS<-as.data.frame(unique(NUEVO_2$EMPRESA))\n    names(EMPRESAS)<-\"EMPRESA\"\n    LIMITE<-dim(EMPRESAS)[1]\n    EMPRESAS$N_ENTIDAD<-1:LIMITE\n    NUEVO_2<-left_join(NUEVO_2,EMPRESAS)\n    #### DEFINE LAS VARIABLES\n    TEMPO<-NUEVO_2\n    RESPUESTA<-\"MES\"\n    TEMPO$RESPUESTA<-RESPUESTA\n    TEMPO$UNIDAD<-TEMPO$TEMPORADA\n    ### CONSTRUYE LA VARIABLE PARA CRUZAR\n    TEMPO<-unite_(TEMPO, \"ESTRATO2\", c(\"RESPUESTA\",\"MES\"))\n    #### GENERA LOS GRUPOS PARA EL CRUCE\n    #### CAMBIAR LA VARIABLE DENTRO DE mean PARA QUE COINCIDA CON RESPUESTA\n    TEMPO2<-TEMPO %>% group_by(UNIDAD,ZONA_DESTINO,ESTRATO2) %>% summarise(mean(KILOS))\n    names(TEMPO2)[4]<-\"TOTAL\"\n    ###### REALIZA EL CRUCE\n    TEMPO3<-TEMPO2 %>% spread(ESTRATO2,TOTAL,fill = 0)\n    TEMPO3<-as.data.frame(TEMPO3)\n    TEMPO3_1<-TEMPO3\n    TEMPO3_1<-unite_(TEMPO3_1, \"ESTRATO3\", c(\"UNIDAD\",\"ZONA_DESTINO\"))\n    rownames(TEMPO3_1) <-as.character(TEMPO3_1[1][,1])\n    TEMPO3_2<-TEMPO3_1[,2:dim(TEMPO3_1)[2]]\n    d3heatmap(TEMPO3_2, scale=\"column\", colors=\"Blues\", \n              k_row = 5, k_col = 5,yaxis_width =100,\n              xaxis_height = 100)\n  }) \n \n  output$heatmap2_1 <- renderPlot({\n    FIN_2<-dim(COMBO_MES)[1]\n    COMBO_MES$MES2<-1:FIN_2\n    if(input$MOMENTO==1){FILTRADO<-MAESTRO_1}\n    if(input$MOMENTO==2){FILTRADO<-filter(MAESTRO_1,VENTA==\"Cosecha\")}\n    if(input$MOMENTO==3){FILTRADO<-filter(MAESTRO_1,VENTA==\"Poscosecha\")}\n    NUEVO_2<-left_join(FILTRADO,COMBO_MES[,c(3:5)],fill = 0)\n    NUEVO_2$EMPRESA<-as.factor(NUEVO_2$EMPRESA)\n    # GENERA CODIGOS PARA PRODUCTOR LOS INCORPORA A LA BASE NUEVO_1\n    EMPRESAS<-as.data.frame(unique(NUEVO_2$EMPRESA))\n    names(EMPRESAS)<-\"EMPRESA\"\n    LIMITE<-dim(EMPRESAS)[1]\n    EMPRESAS$N_ENTIDAD<-1:LIMITE\n    NUEVO_2<-left_join(NUEVO_2,EMPRESAS)\n    #### DEFINE LAS VARIABLES\n    TEMPO<-NUEVO_2\n    TEMPO$UNIDAD<-TEMPO$TEMPORADA\n    if(input$ESTRATO==\"MESES\") {RESPUESTA<-\"ZONA\"}\n    if(input$ESTRATO==\"ZONAS\") {RESPUESTA<-\"MES\"}  \n    TEMPO$RESPUESTA<-RESPUESTA\n    ### CONSTRUYE LA VARIABLE PARA CRUZAR\n    if(input$ESTRATO==\"MESES\") {TEMPO<-unite_(TEMPO, \"ESTRATO2\", c(\"RESPUESTA\",\"ZONA_DESTINO\"))}\n    if(input$ESTRATO==\"ZONAS\") {TEMPO<-unite_(TEMPO, \"ESTRATO2\", c(\"RESPUESTA\",\"MES\"))}  \n    #### GENERA LOS GRUPOS PARA EL CRUCE\n    if(input$ESTRATO==\"MESES\") {TEMPO2<-TEMPO %>% group_by(UNIDAD,MES,ESTRATO2) %>% summarise(mean(KILOS))}\n    if(input$ESTRATO==\"ZONAS\") {TEMPO2<-TEMPO %>% group_by(UNIDAD,ZONA_DESTINO,ESTRATO2) %>% summarise(mean(KILOS))}  \n    #### CAMBIAR LA VARIABLE DENTRO DE mean PARA QUE COINCIDA CON RESPUESTA\n    COLA<-dim(TEMPO2)[2]\n    names(TEMPO2)[4]<-\"TOTAL\"\n    ###### REALIZA EL CRUCE\n    TEMPO3<-TEMPO2 %>% spread(ESTRATO2,TOTAL,fill = 0)\n    TEMPO3<-as.data.frame(TEMPO3)\n    TEMPO3_1<-TEMPO3\n    if(input$ESTRATO==\"MESES\") {TEMPO3_1<-unite_(TEMPO3_1, \"ESTRATO3\", c(\"UNIDAD\",\"MES\"))}\n    if(input$ESTRATO==\"ZONAS\") {TEMPO3_1<-unite_(TEMPO3_1, \"ESTRATO3\", c(\"UNIDAD\",\"ZONA_DESTINO\"))}  \n    rownames(TEMPO3_1) <-as.character(TEMPO3_1[1][,1])\n    TEMPO3_2<-TEMPO3_1[,2:dim(TEMPO3_1)[2]]\n    ################ APLICA LOS FILTROS  #################\n    ######################################################\n    TEMPORADA<-filter(TEMPO3,UNIDAD==input$E_MODELO1)\n    rownames(TEMPORADA) <-as.character(TEMPORADA[2][,1])\n    TEMPORADA<-TEMPORADA[,3:dim(TEMPORADA)[2]]\n    TEMPORADA_1<-TEMPORADA\n    TEMPORADA<-filter(TEMPO3,UNIDAD==input$E_MODELO2)\n    rownames(TEMPORADA) <-as.character(TEMPORADA[2][,1])\n    TEMPORADA<-TEMPORADA[,3:dim(TEMPORADA)[2]]\n    TEMPORADA_2<-TEMPORADA\n    hc1 <- hclust(dist(TEMPORADA_1), \"ave\")\n    hc2 <- hclust(dist(TEMPORADA_2), \"ave\")\n    GRAFICO<-tanglegram(hc1,hc2,k_labels = input$GRUPO_K, k_branches = input$GRUPO_K,\n                        sort=TRUE,common_subtrees_color_branches = TRUE,intersecting=TRUE,main=\"Tanglegrama\")\n    print(entanglement(GRAFICO)) \n  })  \n  \n  plotInput <- reactive({\n    FILTRA<-filter(MAESTRO_4,ANO<2016)\n    FILTRA<-filter(FILTRA,ANO>2011)\n    if(input$FRUTA_3==1){FILTRADO1<-FILTRA}\n    if(input$FRUTA_3==2){FILTRADO1<-filter(FILTRA,ORIGEN==\"I\")}\n    if(input$FRUTA_3==3){FILTRADO1<-filter(FILTRA,ORIGEN==\"N\")}\n    if(input$MOMENTO2==1){FILTRADO<-FILTRADO1}\n    if(input$MOMENTO2==2){FILTRADO<-filter(FILTRADO1,VENTAS==\"Cosecha\")}\n    if(input$MOMENTO2==3){FILTRADO<-filter(FILTRADO1,VENTAS==\"Postcosecha\")}\n    FIN_2<-dim(COMBO_MES)[1]\n    COMBO_MES$MES2<-1:FIN_2\n    NUEVO_2<-left_join(FILTRADO,COMBO_MES[,c(3:5)],fill = 0)\n    #### DEFINE LAS VARIABLES\n    TEMPO<-NUEVO_2\n    TEMPO$UNIDAD<-TEMPO$ANO\n    if(input$ESTRATO_LI==\"MESES\") {RESPUESTA<-\"M\"}\n    if(input$ESTRATO_LI==\"ZONAS\") {RESPUESTA<-\"R\"}  \n    TEMPO$RESPUESTA<-RESPUESTA\n    ### CONSTRUYE LA VARIABLE PARA CRUZAR\n    if(input$ESTRATO_LI==\"MESES\") {TEMPO<-unite_(TEMPO, \"ESTRATO2\", c(\"RESPUESTA\",\"MES\"))}\n    if(input$ESTRATO_LI==\"ZONAS\") {TEMPO<-unite_(TEMPO, \"ESTRATO2\", c(\"RESPUESTA\",\"REGION\"))}  \n    #### GENERA LOS GRUPOS PARA EL CRUCE\n    if(input$ESTRATO_LI==\"MESES\") {TEMPO2<-TEMPO %>% group_by(UNIDAD,ORIGEN,REGION,ESTRATO2) %>% summarise(mean(KILOS))}\n    if(input$ESTRATO_LI==\"ZONAS\") {TEMPO2<-TEMPO %>% group_by(UNIDAD,ORIGEN,MES,ESTRATO2) %>% summarise(mean(KILOS))}  \n    #### CAMBIAR LA VARIABLE DENTRO DE mean PARA QUE COINCIDA CON RESPUESTA\n    COLA<-dim(TEMPO2)[2]\n    names(TEMPO2)[COLA]<-\"TOTAL\"\n    ###### REALIZA EL CRUCE\n    TEMPO3<-TEMPO2 %>% spread(ESTRATO2,TOTAL,fill = 0)\n    TEMPO3<-as.data.frame(TEMPO3)\n    TEMPO3_1<-TEMPO3\n    if(input$ESTRATO_LI==\"MESES\") {TEMPO3_1<-unite_(TEMPO3_1, \"ESTRATO3\", c(\"UNIDAD\",\"ORIGEN\",\"REGION\"))}\n    if(input$ESTRATO_LI==\"ZONAS\") {TEMPO3_1<-unite_(TEMPO3_1, \"ESTRATO3\", c(\"UNIDAD\",\"ORIGEN\",\"MES\"))}  \n    rownames(TEMPO3_1) <-as.character(TEMPO3_1[1][,1])\n    TEMPO3_2<-TEMPO3_1[,2:dim(TEMPO3_1)[2]]\n    ################ APLICA LOS FILTROS  #################\n    ######################################################\n    TEMPORADA<-filter(TEMPO3,UNIDAD==input$E_MODELO1LI)\n    if(input$ESTRATO_LI==\"MESES\") {TEMPORADA<-unite_(TEMPORADA, \"ESTRATO3\", c(\"ORIGEN\",\"REGION\"))}\n    if(input$ESTRATO_LI==\"ZONAS\") {TEMPORADA<-unite_(TEMPORADA, \"ESTRATO3\", c(\"ORIGEN\",\"MES\"))}  \n    rownames(TEMPORADA) <-as.character(TEMPORADA[2][,1])\n    TEMPORADA<-TEMPORADA[,3:dim(TEMPORADA)[2]]\n    TEMPORADA_1<-TEMPORADA\n    TEMPORADA<-filter(TEMPO3,UNIDAD==input$E_MODELO2LI)\n    if(input$ESTRATO_LI==\"MESES\") {TEMPORADA<-unite_(TEMPORADA, \"ESTRATO3\", c(\"ORIGEN\",\"REGION\"))}\n    if(input$ESTRATO_LI==\"ZONAS\") {TEMPORADA<-unite_(TEMPORADA, \"ESTRATO3\", c(\"ORIGEN\",\"MES\"))}  \n    rownames(TEMPORADA) <-as.character(TEMPORADA[2][,1])\n    TEMPORADA<-TEMPORADA[,3:dim(TEMPORADA)[2]]\n    TEMPORADA_2<-TEMPORADA\n    hc1 <- hclust(dist(TEMPORADA_1), \"ave\")\n    hc2 <- hclust(dist(TEMPORADA_2), \"ave\")\n    p<-tanglegram(hc1,hc2,k_labels = input$GRUPO_K2, k_branches = input$GRUPO_K2,\n                  sort=TRUE,common_subtrees_color_branches = TRUE,main=\"Tanglegrama\")      \n     \n\n  })  \n\n  plotInput2 <- function()({\n    FILTRA<-filter(MAESTRO_4,ANO<2016)\n    FILTRA<-filter(FILTRA,ANO>2011)\n    if(input$FRUTA_3==1){FILTRADO1<-FILTRA}\n    if(input$FRUTA_3==2){FILTRADO1<-filter(FILTRA,ORIGEN==\"I\")}\n    if(input$FRUTA_3==3){FILTRADO1<-filter(FILTRA,ORIGEN==\"N\")}\n    if(input$MOMENTO2==1){FILTRADO<-FILTRADO1}\n    if(input$MOMENTO2==2){FILTRADO<-filter(FILTRADO1,VENTAS==\"Cosecha\")}\n    if(input$MOMENTO2==3){FILTRADO<-filter(FILTRADO1,VENTAS==\"Postcosecha\")}\n    FIN_2<-dim(COMBO_MES)[1]\n    COMBO_MES$MES2<-1:FIN_2\n    NUEVO_2<-left_join(FILTRADO,COMBO_MES[,c(3:5)],fill = 0)\n    #### DEFINE LAS VARIABLES\n    TEMPO<-NUEVO_2\n    TEMPO$UNIDAD<-TEMPO$ANO\n    if(input$ESTRATO_LI==\"MESES\") {RESPUESTA<-\"M\"}\n    if(input$ESTRATO_LI==\"ZONAS\") {RESPUESTA<-\"R\"}  \n    TEMPO$RESPUESTA<-RESPUESTA\n    ### CONSTRUYE LA VARIABLE PARA CRUZAR\n    if(input$ESTRATO_LI==\"MESES\") {TEMPO<-unite_(TEMPO, \"ESTRATO2\", c(\"RESPUESTA\",\"MES\"))}\n    if(input$ESTRATO_LI==\"ZONAS\") {TEMPO<-unite_(TEMPO, \"ESTRATO2\", c(\"RESPUESTA\",\"REGION\"))}  \n    #### GENERA LOS GRUPOS PARA EL CRUCE\n    if(input$ESTRATO_LI==\"MESES\") {TEMPO2<-TEMPO %>% group_by(UNIDAD,ORIGEN,REGION,ESTRATO2) %>% summarise(mean(KILOS))}\n    if(input$ESTRATO_LI==\"ZONAS\") {TEMPO2<-TEMPO %>% group_by(UNIDAD,ORIGEN,MES,ESTRATO2) %>% summarise(mean(KILOS))}  \n    #### CAMBIAR LA VARIABLE DENTRO DE mean PARA QUE COINCIDA CON RESPUESTA\n    COLA<-dim(TEMPO2)[2]\n    names(TEMPO2)[COLA]<-\"TOTAL\"\n    ###### REALIZA EL CRUCE\n    TEMPO3<-TEMPO2 %>% spread(ESTRATO2,TOTAL,fill = 0)\n    TEMPO3<-as.data.frame(TEMPO3)\n    TEMPO3_1<-TEMPO3\n    if(input$ESTRATO_LI==\"MESES\") {TEMPO3_1<-unite_(TEMPO3_1, \"ESTRATO3\", c(\"UNIDAD\",\"ORIGEN\",\"REGION\"))}\n    if(input$ESTRATO_LI==\"ZONAS\") {TEMPO3_1<-unite_(TEMPO3_1, \"ESTRATO3\", c(\"UNIDAD\",\"ORIGEN\",\"MES\"))}  \n    rownames(TEMPO3_1) <-as.character(TEMPO3_1[1][,1])\n    TEMPO3_2<-TEMPO3_1[,2:dim(TEMPO3_1)[2]]\n    ################ APLICA LOS FILTROS  #################\n    ######################################################\n    TEMPORADA<-filter(TEMPO3,UNIDAD==input$E_MODELO1LI)\n    if(input$ESTRATO_LI==\"MESES\") {TEMPORADA<-unite_(TEMPORADA, \"ESTRATO3\", c(\"ORIGEN\",\"REGION\"))}\n    if(input$ESTRATO_LI==\"ZONAS\") {TEMPORADA<-unite_(TEMPORADA, \"ESTRATO3\", c(\"ORIGEN\",\"MES\"))}  \n    rownames(TEMPORADA) <-as.character(TEMPORADA[2][,1])\n    TEMPORADA<-TEMPORADA[,3:dim(TEMPORADA)[2]]\n    TEMPORADA_1<-TEMPORADA\n    TEMPORADA<-filter(TEMPO3,UNIDAD==input$E_MODELO2LI)\n    if(input$ESTRATO_LI==\"MESES\") {TEMPORADA<-unite_(TEMPORADA, \"ESTRATO3\", c(\"ORIGEN\",\"REGION\"))}\n    if(input$ESTRATO_LI==\"ZONAS\") {TEMPORADA<-unite_(TEMPORADA, \"ESTRATO3\", c(\"ORIGEN\",\"MES\"))}  \n    rownames(TEMPORADA) <-as.character(TEMPORADA[2][,1])\n    TEMPORADA<-TEMPORADA[,3:dim(TEMPORADA)[2]]\n    TEMPORADA_2<-TEMPORADA\n    hc1 <- hclust(dist(TEMPORADA_1), \"ave\")\n    hc2 <- hclust(dist(TEMPORADA_2), \"ave\")\n    tanglegram(hc1,hc2,k_labels = input$GRUPO_K2, k_branches = input$GRUPO_K2,\n               sort=TRUE,common_subtrees_color_branches = TRUE,main=\"Tanglegrama\")      \n  })  \n  \n  plotInput3 <- function() ({\n    FIN_2<-dim(COMBO_MES)[1]\n    COMBO_MES$MES2<-1:FIN_2\n    if(input$MOMENTO==1){FILTRADO<-MAESTRO_1}\n    if(input$MOMENTO==2){FILTRADO<-filter(MAESTRO_1,VENTA==\"Cosecha\")}\n    if(input$MOMENTO==3){FILTRADO<-filter(MAESTRO_1,VENTA==\"Poscosecha\")}\n    NUEVO_2<-left_join(FILTRADO,COMBO_MES[,c(3:5)],fill = 0)\n    NUEVO_2$EMPRESA<-as.factor(NUEVO_2$EMPRESA)\n    # GENERA CODIGOS PARA PRODUCTOR LOS INCORPORA A LA BASE NUEVO_1\n    EMPRESAS<-as.data.frame(unique(NUEVO_2$EMPRESA))\n    names(EMPRESAS)<-\"EMPRESA\"\n    LIMITE<-dim(EMPRESAS)[1]\n    EMPRESAS$N_ENTIDAD<-1:LIMITE\n    NUEVO_2<-left_join(NUEVO_2,EMPRESAS)\n    #### DEFINE LAS VARIABLES\n    TEMPO<-NUEVO_2\n    TEMPO$UNIDAD<-TEMPO$TEMPORADA\n    if(input$ESTRATO==\"MESES\") {RESPUESTA<-\"ZONA\"}\n    if(input$ESTRATO==\"ZONAS\") {RESPUESTA<-\"MES\"}  \n    TEMPO$RESPUESTA<-RESPUESTA\n    ### CONSTRUYE LA VARIABLE PARA CRUZAR\n    if(input$ESTRATO==\"MESES\") {TEMPO<-unite_(TEMPO, \"ESTRATO2\", c(\"RESPUESTA\",\"ZONA_DESTINO\"))}\n    if(input$ESTRATO==\"ZONAS\") {TEMPO<-unite_(TEMPO, \"ESTRATO2\", c(\"RESPUESTA\",\"MES\"))}  \n    #### GENERA LOS GRUPOS PARA EL CRUCE\n    if(input$ESTRATO==\"MESES\") {TEMPO2<-TEMPO %>% group_by(UNIDAD,MES,ESTRATO2) %>% summarise(mean(KILOS))}\n    if(input$ESTRATO==\"ZONAS\") {TEMPO2<-TEMPO %>% group_by(UNIDAD,ZONA_DESTINO,ESTRATO2) %>% summarise(mean(KILOS))}  \n    #### CAMBIAR LA VARIABLE DENTRO DE mean PARA QUE COINCIDA CON RESPUESTA\n    COLA<-dim(TEMPO2)[2]\n    names(TEMPO2)[4]<-\"TOTAL\"\n    ###### REALIZA EL CRUCE\n    TEMPO3<-TEMPO2 %>% spread(ESTRATO2,TOTAL,fill = 0)\n    TEMPO3<-as.data.frame(TEMPO3)\n    TEMPO3_1<-TEMPO3\n    if(input$ESTRATO==\"MESES\") {TEMPO3_1<-unite_(TEMPO3_1, \"ESTRATO3\", c(\"UNIDAD\",\"MES\"))}\n    if(input$ESTRATO==\"ZONAS\") {TEMPO3_1<-unite_(TEMPO3_1, \"ESTRATO3\", c(\"UNIDAD\",\"ZONA_DESTINO\"))}  \n    rownames(TEMPO3_1) <-as.character(TEMPO3_1[1][,1])\n    TEMPO3_2<-TEMPO3_1[,2:dim(TEMPO3_1)[2]]\n    ################ APLICA LOS FILTROS  #################\n    ######################################################\n    TEMPORADA<-filter(TEMPO3,UNIDAD==input$E_MODELO1)\n    rownames(TEMPORADA) <-as.character(TEMPORADA[2][,1])\n    TEMPORADA<-TEMPORADA[,3:dim(TEMPORADA)[2]]\n    TEMPORADA_1<-TEMPORADA\n    TEMPORADA<-filter(TEMPO3,UNIDAD==input$E_MODELO2)\n    rownames(TEMPORADA) <-as.character(TEMPORADA[2][,1])\n    TEMPORADA<-TEMPORADA[,3:dim(TEMPORADA)[2]]\n    TEMPORADA_2<-TEMPORADA\n    hc1 <- hclust(dist(TEMPORADA_1), \"ave\")\n    hc2 <- hclust(dist(TEMPORADA_2), \"ave\")\n    GRAFICO<-tanglegram(hc1,hc2,k_labels = input$GRUPO_K, k_branches = input$GRUPO_K,sort=TRUE,common_subtrees_color_branches = TRUE,intersecting=TRUE)\n    print(entanglement(GRAFICO)) \n  })  \n  \n  output$heatmap2LI <- renderPlot({\n    print(plotInput())\n    })\n  \n  output$heatmapLI <- renderD3heatmap({\n    FILTRA<-filter(MAESTRO_4,ANO<2016)\n    FILTRA<-filter(FILTRA,ANO>2011)\n    if(input$FRUTA_2==1){FILTRADO1<-FILTRA}\n    if(input$FRUTA_2==2){FILTRADO1<-filter(FILTRA,ORIGEN==\"I\")}\n    if(input$FRUTA_2==3){FILTRADO1<-filter(FILTRA,ORIGEN==\"N\")}\n    if(input$MOMENTO3==1){FILTRADO<-FILTRADO1}\n    if(input$MOMENTO3==2){FILTRADO<-filter(FILTRADO1,VENTAS==\"Cosecha\")}\n    if(input$MOMENTO3==3){FILTRADO<-filter(FILTRADO1,VENTAS==\"Postcosecha\")}\n    FIN_2<-dim(COMBO_MES)[1]\n    COMBO_MES$MES2<-1:FIN_2\n    NUEVO_2<-left_join(FILTRADO,COMBO_MES[,c(3:5)],fill = 0)\n    #### DEFINE LAS VARIABLES\n    TEMPO<-NUEVO_2\n    TEMPO$UNIDAD<-TEMPO$ANO\n    if(input$ESTRATO_LI2==\"MESES\") {RESPUESTA<-\"M\"}\n    if(input$ESTRATO_LI2==\"ZONAS\") {RESPUESTA<-\"R\"}  \n    TEMPO$RESPUESTA<-RESPUESTA\n    ### CONSTRUYE LA VARIABLE PARA CRUZAR\n    if(input$ESTRATO_LI2==\"MESES\") {TEMPO<-unite_(TEMPO, \"ESTRATO2\", c(\"RESPUESTA\",\"MES\"))}\n    if(input$ESTRATO_LI2==\"ZONAS\") {TEMPO<-unite_(TEMPO, \"ESTRATO2\", c(\"RESPUESTA\",\"REGION\"))}  \n        #### GENERA LOS GRUPOS PARA EL CRUCE\n    if(input$ESTRATO_LI2==\"MESES\") {TEMPO2<-TEMPO %>% group_by(UNIDAD,ORIGEN,REGION,ESTRATO2) %>% summarise(mean(KILOS))}\n    if(input$ESTRATO_LI2==\"ZONAS\") {TEMPO2<-TEMPO %>% group_by(UNIDAD,ORIGEN,MES,ESTRATO2) %>% summarise(mean(KILOS))}  \n    #### CAMBIAR LA VARIABLE DENTRO DE mean PARA QUE COINCIDA CON RESPUESTA\n    COLA<-dim(TEMPO2)[2]\n    names(TEMPO2)[COLA]<-\"TOTAL\"\n    ###### REALIZA EL CRUCE\n    TEMPO3<-TEMPO2 %>% spread(ESTRATO2,TOTAL,fill = 0)\n    TEMPO3<-as.data.frame(TEMPO3)\n    TEMPO3_1<-TEMPO3\n    if(input$ESTRATO_LI2==\"MESES\") {TEMPO3_1<-unite_(TEMPO3_1, \"ESTRATO3\", c(\"UNIDAD\",\"ORIGEN\",\"REGION\"))}\n    if(input$ESTRATO_LI2==\"ZONAS\") {TEMPO3_1<-unite_(TEMPO3_1, \"ESTRATO3\", c(\"UNIDAD\",\"ORIGEN\",\"MES\"))}  \n    rownames(TEMPO3_1) <-as.character(TEMPO3_1[1][,1])\n    TEMPO3_2<-TEMPO3_1[,2:dim(TEMPO3_1)[2]]\n    ############## APLICA EL GRAFICO FINAL\n    if(input$TRANSPUESTO) INGRESA<-t(TEMPO3_2) else INGRESA<-TEMPO3_2 \n    d3heatmap(INGRESA, scale=\"column\", colors=\"Blues\", k_row = input$GRUPO_KF1, \n              k_col = input$GRUPO_KC1,yaxis_width =100,xaxis_height = 100)\n      }) \n  \n  output$localPlotLI <- renderPlotly({\n    FILTRA<-filter(MAESTRO_4,ANO<2016)\n    FILTRA<-filter(FILTRA,ANO>2011)\n    if(input$FRUTA_1==1){FILTRADO1<-FILTRA}\n    if(input$FRUTA_1==2){FILTRADO1<-filter(FILTRA,ORIGEN==\"I\")}\n    if(input$FRUTA_1==3){FILTRADO1<-filter(FILTRA,ORIGEN==\"N\")}\n    if(input$MOMENTO4==1){FILTRADO<-FILTRADO1}\n    if(input$MOMENTO4==2){FILTRADO<-filter(FILTRADO1,VENTAS==\"Cosecha\")}\n    if(input$MOMENTO4==3){FILTRADO<-filter(FILTRADO1,VENTAS==\"Postcosecha\")}\n    FIN_2<-dim(COMBO_MES)[1]\n    COMBO_MES$MES2<-1:FIN_2\n    NUEVO_2<-left_join(FILTRADO,COMBO_MES[,c(3:5)],fill = 0)\n    #### DEFINE LAS VARIABLES\n    TEMPO<-NUEVO_2\n    TEMPO$UNIDAD<-TEMPO$ANO\n    if(input$ESTRATO_LI3==\"MESES\") {RESPUESTA<-\"M\"}\n    if(input$ESTRATO_LI3==\"ZONAS\") {RESPUESTA<-\"R\"}  \n    TEMPO$RESPUESTA<-RESPUESTA\n    ### CONSTRUYE LA VARIABLE PARA CRUZAR\n    if(input$ESTRATO_LI3==\"MESES\") {TEMPO<-unite_(TEMPO, \"ESTRATO2\", c(\"RESPUESTA\",\"MES\"))}\n    if(input$ESTRATO_LI3==\"ZONAS\") {TEMPO<-unite_(TEMPO, \"ESTRATO2\", c(\"RESPUESTA\",\"REGION\"))}  \n    #### GENERA LOS GRUPOS PARA EL CRUCE\n    if(input$ESTRATO_LI3==\"MESES\") {TEMPO2<-TEMPO %>% group_by(UNIDAD,ORIGEN,REGION,ESTRATO2) %>% summarise(mean(KILOS))}\n    if(input$ESTRATO_LI3==\"ZONAS\") {TEMPO2<-TEMPO %>% group_by(UNIDAD,ORIGEN,MES,ESTRATO2) %>% summarise(mean(KILOS))}  \n    #### CAMBIAR LA VARIABLE DENTRO DE mean PARA QUE COINCIDA CON RESPUESTA\n    COLA<-dim(TEMPO2)[2]\n    names(TEMPO2)[COLA]<-\"TOTAL\"\n    ###### REALIZA EL CRUCE\n    TEMPO3<-TEMPO2 %>% spread(ESTRATO2,TOTAL,fill = 0)\n    TEMPO3<-as.data.frame(TEMPO3)\n    TEMPO3_1<-TEMPO3\n    if(input$ESTRATO_LI3==\"MESES\") {TEMPO3_1<-unite_(TEMPO3_1, \"ESTRATO3\", c(\"UNIDAD\",\"ORIGEN\",\"REGION\"))}\n    if(input$ESTRATO_LI3==\"ZONAS\") {TEMPO3_1<-unite_(TEMPO3_1, \"ESTRATO3\", c(\"UNIDAD\",\"ORIGEN\",\"MES\"))}  \n    rownames(TEMPO3_1) <-as.character(TEMPO3_1[1][,1])\n    TEMPO3_2<-TEMPO3_1[,2:dim(TEMPO3_1)[2]]\n    ##### identifica los clusters\n    hc <- hclust(dist(TEMPO3_2), \"ave\")\n    GRUPO=cutree(hc,k=input$N_CLUSTER) \n    GRUPO<-as.data.frame(GRUPO)\n    GRUPO$ESTRATO3<-rownames(GRUPO)\n    GRUPO$ESTRATO3<-as.factor(GRUPO$ESTRATO3)\n    TEMPO3_1$ESTRATO3<-as.factor(TEMPO3_1$ESTRATO3)\n    TEMPO5<-left_join(GRUPO, TEMPO3_1)\n    rownames(TEMPO5) <-as.character(TEMPO5[2][,1])\n    TEMPO5<-TEMPO5[,c(1,3:dim(TEMPO5)[2])]\n    V_CP1<-summary(prcomp(TEMPO5[,2:dim(TEMPO5)[2]], scale = TRUE))$importance[2]*100\n    V_CP2<-summary(prcomp(TEMPO5[,2:dim(TEMPO5)[2]], scale = TRUE))$importance[5]*100\n    Var_CP1<-paste(\"Primer Componente (\",V_CP1,\"%)\",sep=\"\")\n    Var_CP2<-paste(\"Segunda Componente (\",V_CP2,\"%)\",sep=\"\")\n    p<-autoplot(prcomp(TEMPO5[,2:dim(TEMPO5)[2]],scale=TRUE),\n                label = TRUE, colour = TEMPO5$GRUPO, label.size = 3,\n                loadings = TRUE, loadings.colour = 'blue',loadings.label = TRUE, \n                loadings.label.size = 4,shape = TRUE, frame = FALSE,\n                xlab =Var_CP1,ylab=Var_CP2,main=\"AnÃ¡lisis de Componentes Principales\")\n    (gg <- ggplotly(p))\n  })\n  \n  output$motionchart <- renderGvis({\n    if (is.null(input$ORIGEN_SN)) return()\n    MAESTRO_6$FECHA<-date(MAESTRO_6$FECHA)\n    DATOS1<-filter(MAESTRO_6,COMPLETO==\"SI\")\n    NEE_ANO<-input$ANO_S\n    DATOS<-filter(DATOS1,ANO_L %in% NEE_ANO)\n    NEE_REGION<-input$REGION_SN\n    DATOS <- filter(DATOS, REGION %in% NEE_REGION)\n    NEE_ORIGEN<-input$ORIGEN_SN\n    DATOS <- filter(DATOS, ORIGEN %in% NEE_ORIGEN)\n    TOTO<-DATOS1 %>%\n      group_by(ORIGEN, REGION,MES) %>%\n      select(KILOS, PRECIO) %>%\n      summarise(\n        KILOS = mean(KILOS, na.rm = TRUE),\n        PRECIO = mean(PRECIO, na.rm = TRUE)) \n    TOTO$ANO_L<-\"Promedio\"\n    TOTO <- filter(TOTO, REGION %in% NEE_REGION)\n    TOTO <- filter(TOTO, ORIGEN %in% NEE_ORIGEN)\n    TOTO_2<-full_join(DATOS,TOTO)\n    TOTO_2$IDENT3<-paste(TOTO_2$ORIGEN,TOTO_2$REGION,TOTO_2$ANO_L,sep=\"-\")\n    TOTO_2$IDENT4<-paste(TOTO_2$ORIGEN,TOTO_2$REGION,TOTO_2$ANO_L,sep=\"-\")\n    TOTO_2$ORIGEN2<-if_else(TOTO_2$ORIGEN==\"MEX\",1,2)\n    ANO1<-filter(DATOS1,ANO_L %in% NEE_ANO)\n    ANO2<-unique(ANO1$ANO)\n    TOTO_2$MES2<-as.Date(ISOdatetime(as.numeric(ANO2),month=TOTO_2$MES,min=0,hour=0,sec=0,day=1))\n    return(gvisMotionChart(TOTO_2,sizevar = \"ORIGEN2\",\n                          idvar=\"IDENT3\",timevar=\"MES2\",colorvar=\"IDENT4\",\n                           xvar = \"KILOS\", yvar = \"PRECIO\"))\n  })  \n  \n  output$Guarda_1 <- downloadHandler(\n    filename = function() {\n      paste(\"grafico-\", Sys.Date(), \".png\", sep=\"\")\n    },\n    content = function(file) {\n      png(file)\n      print(plotInput2())\n      dev.off()\n    })      \n  \n  output$Guarda_2 <- downloadHandler(\n    filename = function() {\n      paste(\"grafico-\", Sys.Date(), \".png\", sep=\"\")\n    },\n    content = function(file) {\n      png(file)\n      print(plotInput3())\n      dev.off()\n    })      \n  \n  output$Guarda_3 <- downloadHandler(\n    filename = function() {\n      paste(\"grafico-\", Sys.Date(), \".html\", sep=\"\")\n    },\n    content = function(file) {\n        FILTRA<-filter(MAESTRO_4,ANO<2016)\n        FILTRA<-filter(FILTRA,ANO>2011)\n        if(input$FRUTA_2==1){FILTRADO1<-FILTRA}\n        if(input$FRUTA_2==2){FILTRADO1<-filter(FILTRA,ORIGEN==\"I\")}\n        if(input$FRUTA_2==3){FILTRADO1<-filter(FILTRA,ORIGEN==\"N\")}\n        if(input$MOMENTO3==1){FILTRADO<-FILTRADO1}\n        if(input$MOMENTO3==2){FILTRADO<-filter(FILTRADO1,VENTAS==\"Cosecha\")}\n        if(input$MOMENTO3==3){FILTRADO<-filter(FILTRADO1,VENTAS==\"Postcosecha\")}\n        FIN_2<-dim(COMBO_MES)[1]\n        COMBO_MES$MES2<-1:FIN_2\n        NUEVO_2<-left_join(FILTRADO,COMBO_MES[,c(3:5)],fill = 0)\n        #### DEFINE LAS VARIABLES\n        TEMPO<-NUEVO_2\n        TEMPO$UNIDAD<-TEMPO$ANO\n        if(input$ESTRATO_LI2==\"MESES\") {RESPUESTA<-\"M\"}\n        if(input$ESTRATO_LI2==\"ZONAS\") {RESPUESTA<-\"R\"}  \n        TEMPO$RESPUESTA<-RESPUESTA\n        ### CONSTRUYE LA VARIABLE PARA CRUZAR\n        if(input$ESTRATO_LI2==\"MESES\") {TEMPO<-unite_(TEMPO, \"ESTRATO2\", c(\"RESPUESTA\",\"MES\"))}\n        if(input$ESTRATO_LI2==\"ZONAS\") {TEMPO<-unite_(TEMPO, \"ESTRATO2\", c(\"RESPUESTA\",\"REGION\"))}  \n        #### GENERA LOS GRUPOS PARA EL CRUCE\n        if(input$ESTRATO_LI2==\"MESES\") {TEMPO2<-TEMPO %>% group_by(UNIDAD,ORIGEN,REGION,ESTRATO2) %>% summarise(mean(KILOS))}\n        if(input$ESTRATO_LI2==\"ZONAS\") {TEMPO2<-TEMPO %>% group_by(UNIDAD,ORIGEN,MES,ESTRATO2) %>% summarise(mean(KILOS))}  \n        #### CAMBIAR LA VARIABLE DENTRO DE mean PARA QUE COINCIDA CON RESPUESTA\n        COLA<-dim(TEMPO2)[2]\n        names(TEMPO2)[COLA]<-\"TOTAL\"\n        ###### REALIZA EL CRUCE\n        TEMPO3<-TEMPO2 %>% spread(ESTRATO2,TOTAL,fill = 0)\n        TEMPO3<-as.data.frame(TEMPO3)\n        TEMPO3_1<-TEMPO3\n        if(input$ESTRATO_LI2==\"MESES\") {TEMPO3_1<-unite_(TEMPO3_1, \"ESTRATO3\", c(\"UNIDAD\",\"ORIGEN\",\"REGION\"))}\n        if(input$ESTRATO_LI2==\"ZONAS\") {TEMPO3_1<-unite_(TEMPO3_1, \"ESTRATO3\", c(\"UNIDAD\",\"ORIGEN\",\"MES\"))}  \n        rownames(TEMPO3_1) <-as.character(TEMPO3_1[1][,1])\n        TEMPO3_2<-TEMPO3_1[,2:dim(TEMPO3_1)[2]]\n        ############## APLICA EL GRAFICO FINAL\n        if(input$TRANSPUESTO) INGRESA<-t(TEMPO3_2) else INGRESA<-TEMPO3_2 \n        AA<-  d3heatmap(INGRESA, scale=\"column\", colors=\"Blues\", \n                      k_row = input$GRUPO_KF1, k_col = input$GRUPO_KC1,yaxis_width =100,\n                      xaxis_height = 100)\n      saveWidget(AA,file)\n  \n    })\n  \n  output$Guarda_4 <- downloadHandler(\n    filename = function() {\n      paste(\"grafico-\", Sys.Date(), \".html\", sep=\"\")\n    },\n    content = function(file) {\n      FIN_2<-dim(COMBO_MES)[1]\n      COMBO_MES$MES2<-1:FIN_2\n      NUEVO_2<-left_join(MAESTRO_1,COMBO_MES[,c(3:5)],fill = 0)\n      NUEVO_2$EMPRESA<-as.factor(NUEVO_2$EMPRESA)\n      # GENERA CODIGOS PARA PRODUCTOR LOS INCORPORA A LA BASE NUEVO_1\n      EMPRESAS<-as.data.frame(unique(NUEVO_2$EMPRESA))\n      names(EMPRESAS)<-\"EMPRESA\"\n      LIMITE<-dim(EMPRESAS)[1]\n      EMPRESAS$N_ENTIDAD<-1:LIMITE\n      NUEVO_2<-left_join(NUEVO_2,EMPRESAS)\n      #### DEFINE LAS VARIABLES\n      TEMPO<-NUEVO_2\n      RESPUESTA<-\"MES\"\n      TEMPO$RESPUESTA<-RESPUESTA\n      TEMPO$UNIDAD<-TEMPO$TEMPORADA\n      ### CONSTRUYE LA VARIABLE PARA CRUZAR\n      TEMPO<-unite_(TEMPO, \"ESTRATO2\", c(\"RESPUESTA\",\"MES\"))\n      #### GENERA LOS GRUPOS PARA EL CRUCE\n      #### CAMBIAR LA VARIABLE DENTRO DE mean PARA QUE COINCIDA CON RESPUESTA\n      TEMPO2<-TEMPO %>% group_by(UNIDAD,ZONA_DESTINO,ESTRATO2) %>% summarise(mean(KILOS))\n      names(TEMPO2)[4]<-\"TOTAL\"\n      ###### REALIZA EL CRUCE\n      TEMPO3<-TEMPO2 %>% spread(ESTRATO2,TOTAL,fill = 0)\n      TEMPO3<-as.data.frame(TEMPO3)\n      TEMPO3_1<-TEMPO3\n      TEMPO3_1<-unite_(TEMPO3_1, \"ESTRATO3\", c(\"UNIDAD\",\"ZONA_DESTINO\"))\n      rownames(TEMPO3_1) <-as.character(TEMPO3_1[1][,1])\n      TEMPO3_2<-TEMPO3_1[,2:dim(TEMPO3_1)[2]]\n      AA<-d3heatmap(TEMPO3_2, scale=\"column\", colors=\"Blues\", k_row = 5, \n                    k_col = 5,yaxis_width =100,xaxis_height = 100)\n\n      saveWidget(AA,file)\n          })\n      \n  output$Serie1 <- renderHighchart({\n    if (is.null(input$ORIGEN_SN2)) return()\n    DATOS1<-filter(MAESTRO_6,COMPLETO==\"SI\")\n    DATOS<-filter(DATOS1,Ano==levels(as.factor(input$ANO_S2)))\n    NEE_REGION<-as.character(levels(as.factor(input$REGION_SN2)))\n    DATOS <- filter(DATOS, Region==NEE_REGION)\n    NEE_ORIGEN<-as.character(levels(as.factor(input$ORIGEN_SN)))\n    DATOS <- filter(DATOS, Origen==NEE_ORIGEN)\n    DATOS$Ano<-as.character(DATOS$Ano)\n    TOTO<-DATOS1 %>%\n      group_by(Origen, Region,Mes) %>%\n      select(Kilos, Precio) %>%\n      summarise(\n        Kilos = mean(Kilos, na.rm = TRUE),\n        Precio = mean(Precio, na.rm = TRUE)) \n    TOTO$Ano<-\"Promedio\"\n    TOTO <- filter(TOTO, Region==NEE_REGION)\n    TOTO <- filter(TOTO, Origen==NEE_ORIGEN)\n    TOTO_2<-full_join(DATOS,TOTO)\n    TOTO_2$Ident3<-paste(TOTO_2$Origen,TOTO_2$Region,TOTO_2$Ano,sep=\"-\")\n    TOTO_2$Ident4<-paste(TOTO_2$Origen,TOTO_2$Region,TOTO_2$Ano,sep=\"-\")\n    TOTO_2$Origen2<-if_else(TOTO_2$Origen==\"MEX\",1,2)\n    TOTO_2$Mes2<-as.Date(ISOdatetime(as.numeric(input$ANO_S),month=TOTO_2$Mes,min=0,hour=0,sec=0,day=1))\n    TOTO_2$Fecha2 <- months(TOTO_2$Fecha)\n    highchart() %>%     \n      hc_xAxis(categories = TOTO_2$Fecha2) %>% \n      hc_yAxis_multiples(\n        list(top = \"0%\", height = \"30%\", lineWidth = 3),\n        list(top = \"30%\", height = \"70%\", offset = 0,\n             showFirstLabel = FALSE, showLastLabel = FALSE)) %>% \n      hc_add_series(name = \"Precio\", data = TOTO_2$Precio) %>% \n      hc_add_series(name = \"Kilos\", data = TOTO_2$Kilos, yAxis = 1)\n  })    \n\n#  output$Serie2 <- renderPlotly({\n   output$Serie2 <- renderPlot({\n    if (is.null(input$ORIGEN_SN2)) return()\n\n    DATOS1<-filter(MAESTRO_6,COMPLETO==\"SI\")\n    DATOS1$FECHA2 <- month(DATOS1$FECHA)\n    DATOS1$MOMENTO<-ifelse(DATOS1$FECHA2<8,\"Postcosecha\",\"Cosecha\") \n    NEE_ANO<-input$ANO_S2\n    DATOS<-filter(DATOS1,ANO_L %in% NEE_ANO)\n    NEE_REGION<-input$REGION_SN2\n    DATOS <- filter(DATOS, REGION %in% NEE_REGION)\n    NEE_ORIGEN<-input$ORIGEN_SN2\n    DATOS <- filter(DATOS, ORIGEN %in% NEE_ORIGEN)\n    DATOS$FECHA2 <- month(DATOS$FECHA)\n    TOTO<-DATOS1 %>%\n      group_by(ORIGEN, REGION,FECHA2,MOMENTO) %>%\n      select(KILOS, PRECIO) %>%\n      summarise(\n        KILOS = mean(KILOS, na.rm = TRUE),\n        PRECIO = mean(PRECIO, na.rm = TRUE)) \n    TOTO$ANO_L<-\"Promedio\"\n    TOTO <- filter(TOTO, REGION %in% NEE_REGION)\n    TOTO <- filter(TOTO, ORIGEN %in% NEE_ORIGEN)\n    TOTO_2<-full_join(DATOS,TOTO)\n    TOTO_2$IDENT3<-paste(TOTO_2$ORIGEN,TOTO_2$REGION,TOTO_2$ANO_L,sep=\"-\")\n    TOTO_2$IDENT4<-paste(TOTO_2$ORIGEN,TOTO_2$REGION,TOTO_2$ANO_L,sep=\"-\")\n    TOTO_2$ORIGEN2<-if_else(TOTO_2$ORIGEN==\"MEX\",1,2)\n    LARGO<-melt(TOTO_2,id=c(\"ANO_L\",\"FECHA2\",\"ORIGEN\",\"REGION\",\"IDENT3\",\"MOMENTO\"),measure=c(\"KILOS\",\"PRECIO\"))\n    p<-ggplot(aes(FECHA2,value),data=LARGO,group=IDENT3,xlab=\"Meses\")+geom_point()+\n    geom_smooth(se = FALSE,span = input$SPAN)+ scale_y_continuous(breaks = 1:12) + facet_grid(variable~MOMENTO,scales=\"free\")+\n      theme(strip.text.x = element_text(size=12, face=\"bold\"),\n            strip.text.y = element_text(size=12, face=\"bold\"),\n            strip.background = element_rect(colour=\"red\", fill=\"#CCCCFF\"))+\n               aes(color=IDENT3)\n    print(p)\n#    ggplotly(p)\n  })    \n\n  output$REGION_S <- renderUI({\n    if (is.null(input$ANO_S)) return(\"    \")\n    DATOS<-filter(MAESTRO_6,COMPLETO==\"SI\")\n    ANOS<-input$ANO_S\n    DATOS<-filter(DATOS,ANO_L %in% ANOS)\n    NEE_REGION<-levels(as.factor(DATOS$REGION))\n    selectInput(\"REGION_SN\",label = h5(\"Region:\"),multiple = TRUE,\n                choices=NEE_REGION,\n                helpText(\"Elija\"))    \n  })\n  \n  output$ORIGEN_S <- renderUI({\n    if (is.null(input$REGION_SN)) return(\"    \")\n    DATOS<-filter(MAESTRO_6,COMPLETO==\"SI\")\n    ANOS<-input$ANO_S\n    DATOS<-filter(DATOS,ANO_L %in% ANOS)\n    NEE_REGION<-input$REGION_SN\n    DATOS <- filter(DATOS, REGION %in% NEE_REGION)\n    NNE_ORIGEN<-levels(as.factor(DATOS$ORIGEN))\n    selectInput(\"ORIGEN_SN\",label = h5(\"Origen:\"),\n                choices = NNE_ORIGEN, \n                multiple = TRUE,\n                helpText(\"Elija\"))    \n  })\n  \n  output$REGION_S2 <- renderUI({\n    if (is.null(input$ANO_S2)) return(\"    \")\n    DATOS<-filter(MAESTRO_6,COMPLETO==\"SI\")\n    ANOS<-input$ANO_S2\n    DATOS<-filter(DATOS,ANO_L %in% ANOS)\n    NEE_REGION<-levels(as.factor(DATOS$REGION))\n    selectInput(\"REGION_SN2\",label = h5(\"Region:\"),multiple = TRUE,\n                choices=NEE_REGION,\n                helpText(\"Elija\"))    \n  })\n  \n    output$ORIGEN_S2 <- renderUI({\n    if (is.null(input$REGION_SN2)) return(\"    \")\n    DATOS<-filter(MAESTRO_6,COMPLETO==\"SI\")\n    ANOS<-input$ANO_S2\n    DATOS<-filter(DATOS,ANO_L %in% ANOS)\n    NEE_REGION<-input$REGION_SN2\n    DATOS <- filter(DATOS, REGION %in% NEE_REGION)\n    NNE_ORIGEN<-levels(as.factor(DATOS$ORIGEN))\n    selectInput(\"ORIGEN_SN2\",label = h5(\"Origen:\"),\n                choices = NNE_ORIGEN, \n                multiple = TRUE,\n                helpText(\"Elija\"))    \n  })\n\n  output$table <- DT::renderDataTable(DT::datatable({\n    \n    ANOS<-input$M_ANOS\n    FILTRA<-filter(MAESTRO_4,ANO  %in% ANOS)\n    ORIGENES<-input$M_ORIGENES\n    FILTRA<-filter(FILTRA,ORIGEN  %in% ORIGENES)\n    MESES<-input$M_MESES\n    FILTRA<-filter(FILTRA,MES  %in% MESES)\n    FILTRA$REGION<-as.factor(FILTRA$REGION)\n    \n    TOTO<-FILTRA %>%\n      group_by(REGION) %>%\n      select(KILOS) %>%\n      summarise(\n        value = mean(KILOS, na.rm = TRUE)) \n    TOTO1<-as.data.frame(TOTO)\n    REGION_G1<-as.data.frame(REGION_G)\n    TOTO1$Region_G<-as.character(TOTO1$REGION)\n    REGION_G1$Region_G<-as.character(REGION_G1$Region_G)\n    TOTO2<-left_join(REGION_G1,TOTO1,by=\"Region_G\")\n    TOTO3<-TOTO2[,c(3:5)]\n    TOTO3$value[is.na(TOTO3$value)] <- 0\n    MEXICO_0<-df_mxstate\n    MEXICO<-full_join(MEXICO_0,TOTO3)\n    MEXICO$value[is.na(MEXICO$value)] <- 0\n    MEXICO\n    \n  },extensions = 'Scroller', options = list(deferRender = TRUE,dom = \"frtiS\",\n                                           scrollY = 200,scrollX = TRUE,scrollCollapse = TRUE)))  \n\n  output$mapa <- renderPlot({\n#  output$map <- renderLeaflet({\n    ANOS<-input$M_ANOS\n    FILTRA<-filter(MAESTRO_4,ANO  %in% ANOS)\n    ORIGENES<-input$M_ORIGENES\n    FILTRA<-filter(FILTRA,ORIGEN  %in% ORIGENES)\n    MESES<-input$M_MESES\n    FILTRA<-filter(FILTRA,MES  %in% MESES)\n    FILTRA$REGION<-as.factor(FILTRA$REGION)\n    TOTO<-FILTRA %>%\n      group_by(REGION) %>%\n      select(KILOS) %>%\n      summarise(\n        value = mean(KILOS, na.rm = TRUE)) \n    TOTO1<-as.data.frame(TOTO)\n    REGION_G1<-as.data.frame(REGION_G)\n    TOTO1$Region_G<-as.character(TOTO1$REGION)\n    REGION_G1$Region_G<-as.character(REGION_G1$Region_G)\n    TOTO2<-left_join(REGION_G1,TOTO1,by=\"Region_G\")\n    TOTO3<-TOTO2[,c(3:5)]\n    TOTO3$value[is.na(TOTO3$value)] <- 0\n    MEXICO_0<-df_mxstate\n    MEXICO<-full_join(MEXICO_0,TOTO3)\n    MEXICO$value[is.na(MEXICO$value)] <- 0\n    TITULO<-paste(\"Volumen por Region: AÃ±o: \",ANOS,\"  -Origen: \",ORIGENES,\"  -Mes: \",MESES,sep=\"\")\n    PP<-mxstate_choropleth(MEXICO, title = TITULO,num_colors = 7) \n    print(PP)\n      })\n  \n  \n  })\n\n\n\n",
    "created" : 1475549986159.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3717038990",
    "id" : "239B0E92",
    "lastKnownWriteTime" : 1477284854,
    "last_content_update" : 1477284854894,
    "path" : "~/Documentos/CARPETA VALENTIN/ASESORIAS/GIACINTI/2016/ANALYTICS/MEXICO ANALITIC/MEXICO/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}